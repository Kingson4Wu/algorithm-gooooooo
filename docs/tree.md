+ <https://mp.weixin.qq.com/s/UaldrurL6_HOUwhTmZB5wQ>

### 二叉查找树
+ 最常见的树结构是二叉查找树（ Binary Search Tree），它就是一棵二叉有序树：保证左子树上所有节点的值都小于根节点的值，而右子树上所有节点的值都大于根节点的值。其优点在于实现简单，并且树在平衡的状态下查找效率能达到 O(logଶ)；缺点是在极端非平衡情况下查找效率会退化到 O()，因此很难保证索引的效率。

### 平衡二叉树
+ 针对上述二叉查找树的缺点，人们很自然就想到是否能用平衡二叉树（ Balanced Binary Tree）来解决这个问题。但是平衡二叉树依然有个比较大的问题：它的树高为 logଶ——对于索引树来说，树的高度越高，意味着查找所要花费的访问次数越多，查询效率越低。
况且，主存从磁盘读数据一般以页为单位，因此每次访问磁盘都会读取多个扇区的数据.
（比如 4KB大小的数据），远大于单个二叉树节点的值（字节级别），这也是造成二叉树相对索引树效率低下的原因。正因如此，人们就想到了通过增加每个树节点的度来提高访问效率，而 B+树（B+-tree）便受到了更多的关注。
+ 二叉树的度代表某个结点的孩子或者说直接后继的个数，1度是只有一个孩子或者说单子树，2度是有两个孩子或者说左右子树都有
二叉树的最大度为2

### B+树
+ 在传统的关系型数据库里， B+树（ B+-tree）及其衍生树是被用得比较多的索引树。
+ B+树的主要特点如下。
  1. 每个树节点只存放键值，不存放数值，而由叶子节点存放数值。这样会使树节点的度比较大，而树的高度就比较低，从而有利于提高查询效率。
  2. 叶子节点存放数值，并按照值大小顺序排序，且带指向相邻节点的指针，以便高效地进行区间数据查询；并且所有叶子节点与根节点的距离相同，因此任何查询的效率都很相似。
  3. 与二叉树不同， B+树的数据更新操作不从根节点开始，而从叶子节点开始，并且在更新过程中树能以比较小的代价实现自平衡。
+ 正是由于 B+树的上述优点，它成了传统关系型数据库的宠儿。当然，它也并非无懈可击，它的主要缺点在于随着数据插入的不断发生，叶子节点会慢慢分裂——这可能会导致逻辑上原本连续的数据实际上存放在不同的物理磁盘块位置上，在做范围查询的时候会导致较高的磁盘 IO，以致严重影响到性能。


### 红黑树
+ https://mp.weixin.qq.com/s/cnDx8lJ6fXHgLZWsqjWrag

+ 红黑树（Red-Black Tree）是一种自平衡的二叉搜索树（BST），它的主要优点是在最坏情况下依然能保持较高的操作效率，所以在需要频繁插入、删除和查找的场景中表现优秀。
+ Java 中的 TreeMap / TreeSet

<pre>
二叉查找树（BST）具备什么特性呢？

1.左子树上所有结点的值均小于或等于它的根结点的值。
2.右子树上所有结点的值均大于或等于它的根结点的值。
3.左、右子树也分别为二叉排序树。

缺陷体现在插入新节点的时候

红黑树是一种自平衡的二叉查找树

1.结点是红色或黑色。
2.根结点是黑色。
3.每个叶子结点都是黑色的空结点（NIL结点）。
4 每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)
5.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。


变色：

为了重新符合红黑树的规则，尝试把红色结点变为黑色，或者把黑色结点变为红色。

下图所表示的是红黑树的一部分（子树），新插入的结点Y是红色结点，它的父亲结点X也是红色的，不符合规则4，因此我们可以把结点X从红色变成黑色：



但是，仅仅把一个结点变色，会导致相关路径凭空多出一个黑色结点，这样就打破了规则5。因此，我们需要对其他结点做进一步的调整，后文会详细说明。


左旋转：

逆时针旋转红黑树的两个结点，使得父结点被自己的右孩子取代，而自己成为自己的左孩子。说起来很怪异，大家看下图：



图中，身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。


右旋转：

顺时针旋转红黑树的两个结点，使得父结点被自己的左孩子取代，而自己成为自己的右孩子。大家看下图：



图中，身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。




局面1：新结点（A）位于树根，没有父结点。


(空心三角形代表结点下面的子树)

这种局面，直接让新结点变色为黑色，规则2得到满足。同时，黑色的根结点使得每条路径上的黑色结点数目都增加了1，所以并没有打破规则5。



局面2：新结点（B）的父结点是黑色。

这种局面，新插入的红色结点B并没有打破红黑树的规则，所以不需要做任何调整。



局面3：新结点（D）的父结点和叔叔结点都是红色。


这种局面，两个红色结点B和D连续，违反了规则4。因此我们先让结点B变为黑色：


这样一来，结点B所在路径凭空多了一个黑色结点，打破了规则5。因此我们让结点A变为红色：



这时候，结点A和C又成为了连续的红色结点，我们再让结点C变为黑色：



经过上面的调整，这一局部重新符合了红黑树的规则。


局面4：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。


我们以结点B为轴，做一次左旋转，使得新结点D成为父结点，原来的父结点B成为D的左孩子：


这样一来，进入了局面5。

局面5：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。


我们以结点A为轴，做一次右旋转，使得结点B成为祖父结点，结点A成为结点B的右孩子：


接下来，我们让结点B变为黑色，结点A变为红色：


经过上面的调整，这一局部重新符合了红黑树的规则。


以上就是红黑树插入操作所涉及的5种局面。

或许有人会问，如果局面4和局面5当中的父结点B是祖父结点A的右孩子该怎么办呢？

很简单，如果局面4中的父结点B是右孩子，则成为了局面5的镜像，原本的右旋操作改为左旋；如果局面5中的父结点B是右孩子，则成为了局面4的镜像，原本的左旋操作改为右旋。


</pre>


### 日志结构合并树

+ 日志结构合并树（LSM Tree，Log-Structured Merge-Tree）是一种为写优化设计的树形结构，广泛应用于现代数据库和存储系统中。它通过将写操作先缓存在内存中，然后批量合并写入磁盘，以降低磁盘写放大、提升写性能。
+ 写入不直接落盘，而是追加写（Append-only）；LSM Tree 设计的目标是“读少写多”；NoSQL（TiKV（TiDB 的分布式存储引擎）） / 日志（Kafka ） / 时间序列数据库（TSDB）：如 InfluxDB、Prometheus
+ LSM Tree 是为高写入吞吐设计的存储结构，非常适合“写多读少”的业务场景，但需要配合缓存、Bloom Filter 和合理的 compaction 策略来弥补读性能。

+  众所周知，数据库的数据大多存储在磁盘上，而无论是传统的机械硬盘（ HardDiskDrive, HDD）还是固态硬盘（ Solid State Drive, SSD），对磁盘数据的顺序读写速度都远高于随机读写。
+ 然而，基于 B+树的索引结构是违背上述磁盘基本特点的——它会需要较多的磁盘随机读写，于是， 1992年，名为日志结构（ Log-Structured）的新型索引结构方法便应运而生。日志结构方法的主要思想是将磁盘看作一个大的日志，每次都将新的数据及其索引结构添加到日志的最末端，以实现对磁盘的顺序操作，从而提高索引性能。不过，日志结构方法也有明显的缺点，随机读取数据时效率很低。 1996年，一篇名为 Thelog-structured merge-tree（LSM-tree）的论文创造性地提出了日志结构合并树（ Log-Structured Merge-Tree）的概念，该方法既吸收了日志结构方法的优点，又通过将数据文件预排序克服了日志结构方法随机读性能较差的问题。尽管当时 LSM-tree新颖且优势鲜明，但它真正声名鹊起却是在 10年之后的 2006年，那年谷歌的一篇使用了 LSM-tree技术的论文 Bigtable: A Distributed Storage System for Structured Data横空出世，在分布式数据处理领域掀起了一阵旋风，随后两个声名赫赫的大数据开源组件（ 2007年的 HBase与 2008年的 Cassandra，目前两者同为 Apache顶级项目）直接在其思想基础上破茧而出，彻底改变了大数据基础组件的格局，同时也极大地推广了 LSM-tree技术。
+ LSM-tree最大的特点是同时使用了两部分类树的数据结构来存储数据，并同时提供查询。其中一部分数据结构（ C0树）存在于内存缓存（通常叫作 memtable）中，负责接受新的数据插入更新以及读请求，并直接在内存中对数据进行排序；另一部分数据结构（ C1树）存在于硬盘上 (这部分通常叫作 sstable)，它们是由存在于内存缓存中的 C0树冲写到磁盘而成的，主要负责提供读操作，特点是有序且不可被更改。
+ LSM-tree的另一大特点是除了使用两部分类树的数据结构外，还会使用日志文件（通常叫作 commit log）来为数据恢复做保障。这三类数据结构的协作顺序一般是：所有的新插入与更新操作都首先被记录到 commit log中——该操作叫作 WAL（Write Ahead Log），然后再写到 memtable，最后当达到一定条件时数据会从 memtable冲写到 sstable，并抛弃相关的 log数据； memtable与 sstable可同时供查询；当 memtable出问题时，可从 commit log与 sstable中将 memtable的数据恢复。
+ LSM-tree的这种结构非常有利于数据的快速写入（理论上可以接近磁盘顺序写速度），但是不利于读
LSM-tree采取了以下主要的相关措施。
  1. 定期将硬盘上小的 sstable合并（通常叫作 Merge或 Compaction操作）成大的 sstable，以减少 sstable的数量。而且，平时的数据更新删除操作并不会更新原有的数据文件，只会将更新删除操作加到当前的数据文件末端，只有在 sstable合并的时候才会真正将重复的操作或更新去重、合并。
  2. 对每个 sstable使用布隆过滤器（ Bloom Filter），以加速对数据在该 sstable的存在性进行判定，从而减少数据的总查询时间。
+ LSM-tree显然比较适合那些数据插入操作远多于数据更新删除操作与读操作的场景，同时 Druid在一开始就是为时序数据场景设计的，而该场景正好符合 LSM-tree的优势特点，因此 Druid架构便顺理成章地吸取了 LSM-tree的思想。
