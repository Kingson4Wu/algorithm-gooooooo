# 其他
+ 蓄水池抽样算法（Reservoir Sampling）:<https://www.jianshu.com/p/7a9ea6ece2af>

## 如何在500w个单词中统计特定前缀的单词有多少个？
+ 题⽬：我有500w个单词，你帮忙设计⼀个数据结构来进⾏存储，存好之后，我有两个需求。
    - 1、来了⼀个新的单词，需要判断是否在这500w个单词中
    - 2、来了⼀个单词前缀，给出500w个单词中有多少个单词是该前缀
+ ssogo/core/trie.go (前缀匹配树) - 字典树- trie树
    - algorithm-gooooooo/docs/interview/trie/trie.go
    - 不需要考虑重复单词的情况，用isEnd，有重复单词，就改成用count
+ /algorithm-gooooooo/docs/interview/trie.go

## 5 亿整数的⼤⽂件，来排个序？
+ 题⽬：给你1个⽂件bigdata，⼤⼩4663M，5亿个数，⽂件中的数据随机,如下⼀⾏⼀个整数
+ 外部排序：内存极少的情况下，利⽤分治策略，利⽤外存保存中间结果，再⽤多路归并来排序; map-reduce的嫡系
1. 分
    - 内存中维护⼀个极⼩的核⼼缓冲区memBuffer，将⼤⽂件bigdata按⾏读⼊，搜集到memBuffer
      满或者⼤⽂件读完时，对memBuffer中的数据调⽤内排进⾏排序，排序后将有序结果写⼊磁盘
      ⽂件bigdata.xxx.part.sorted. 循环利⽤memBuffer直到⼤⽂件处理完毕，得到n个有序的磁盘⽂
      件
2. 合
    - 归并排序
    - <pre>
   我们举个简单的例⼦：
   ⽂件1：3,6,9 ⽂件2：2,4,8 ⽂件3：1,5,7
   第⼀回合：⽂件1的最⼩值：3 , 排在⽂件1的第1⾏ ⽂件2的最⼩值：2，排在⽂件2的第1⾏ ⽂
   件3的最⼩值：1，排在⽂件3的第1⾏ 那么，这3个⽂件中的最⼩值是：min(1,2,3) = 1 也就是
   说，最终⼤⽂件的当前最⼩值，是⽂件1、2、3的当前最⼩值的最⼩值，绕么？上⾯拿出了最⼩
   值1，写⼊⼤⽂件.
   第⼆回合：⽂件1的最⼩值：3 , 排在⽂件1的第1⾏ ⽂件2的最⼩值：2，排在⽂件2的第1⾏ ⽂
   件3的最⼩值：5，排在⽂件3的第2⾏ 那么，这3个⽂件中的最⼩值是：min(5,2,3) = 2 将2写⼊
   ⼤⽂件.
   也就是说，最⼩值属于哪个⽂件，那么就从哪个⽂件当中取下⼀⾏数据.（因为⼩⽂件内部有
   序，下⼀⾏数据代表了它当前的最⼩值）
   </pre>

## 如何从 100 亿 URL 中找出相同的 URL
+ 给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。
+ algorithm-gooooooo/Algorithm/interview/100billion/如何从 100 亿 URL 中找出相同的 URL.go
1. 分而治之，进行哈希取余，分开存文件；
2. 对每个子文件进行 HashSet 统计；
3. 如果分完还有很大的文件，那就文件再继续分，一直递归到文件符合设置的最大大小即可
4. 对下标一样的a、b文件进行对比（文件较小，直接加载到hashmap对比即可）

+ 其他：采用Bloom filter，假设布隆过滤器的错误率为0.01，则位数组大小m约为输入元素个数n的13倍，此时需要的哈希函数k约为8个。
  + 元素个数：n = 5G
    位数组大小：m = 5G * 13 = 65G = 650亿 即需要650亿个bit位才能达到错误率0.01
    而我们拥有的内存可容纳bit位个数：4G * 8bit = 32G bit = 320亿，按此实现错误率大于0.01。
  + Bloom Filter(布隆过滤器)的概念和原理: <http://blog.csdn.net/dadoneo/article/details/6847481>

## 什么是字符串匹配算法？
+ 题目：给你两个字符串 A和 B，请你判断 B 是否是 A的子串，并返回B在A中第一次出现的位置。
+ 假设主串的长度是m，模式串的长度是n，那么在这种极端情况下，BF算法的最坏时
  间复杂度是O（mn）。
+ BF 算法只是简单粗暴地对两个字符串的所有字符依次比较,而K算法比较的是两个字符串的[哈希值 ]。
    1. 我们需要⽣成模式串的hashcode （比如按位相加， bce = 2 + 3 + 5 = 10）
    2. ⽣成主串当中第⼀个等长⼦串的hashcode。
    3. ⽐较两个hashcode。
    4. ⽣成主串当中第⼆个等长⼦串的hashcode。
    5. ⽐较两个hashcode。
    6. ⽣成主串当中第三个等长⼦串的hashcode。
    7. 以此类推，当hashcode相等时
    8. 逐个字符⽐较两字符串。
    + 注意hashcode无需重复计算（由 于新⼦串的前⾯少了⼀个a，后⾯多了⼀个d，所以： 新hashcode = 旧hashcode - 1 + 4 = 26-1+4 = 29）
+ RK 算法的缺点在于哈希冲突。每一次哈希冲突的时候，K 算法都要对子串和模式串进行逐个字符的比较,如果冲突太多了，K 算法就退化成了 BF 算法。
+ 以后要是有时间，我会介绍更多的字符串匹配算法，比如 BM算法,比如KMP 算法。它们不但思路巧妙，性能也更加稳定。todo


