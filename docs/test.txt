0, 10], [8, 12], [14, 18], [19, 21], [20, 31], [21, 39], [25, 27], [28, 30], [31, 35




# 复习点
！！！为重点看

3. 最长不含重复字符的子字符串
双指针（即滑动窗口）+ hashmap

76. 最小覆盖子串
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
滑动窗口（增加队列，保存下一次的滑动窗口的left）
hashmap 计算满足的数量 提示判断效率

5. 最长回文子串
(动态规划)
用 P(i,j) 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成 s[i:j]）是否为回文串

11. 盛最多水的容器 ！！！
【两根柱子组成的最大面积！！！】
【左右两个指针，小的先移动（为了寻找更大的）】

计算两边指针的最大容量（取决于矮的那个） - 左右指针对比，移动高度更小的指针
left, right := 0, len(height)-1
for left < right {

15. 三数之和 ！！！
返回所有和为 0 且不重复的三元组。

排序+双指针！！！

【双循环】
【遍历，选i为第一个】
【i的右边的区间，设左右指针，找出剩下两个的所有组合】
【i的数值有重复跳过，另外两个数有重复的跳过】
 if i > 0 && nums[i] == nums[i-1] {
 for left < right {
 for left < right && nums[left] == nums[left+1] {
     left++
 }
 for left < right && nums[right] == nums[right-1] {
     right--
 }

1、先排序，从小到大！！！
2、遍历nums选中i作为第一个数，其他的从这个数的右边找，左右两边双指针往中间计算（left, right := i+1, len(nums)-1）
3、注意计算结果不重复，需对一些条件跳过当前循环

17. 电话号码的字母组合
构造性DFS → 不需要 for 循环
每一层只能处理一个位置的选项，只做一位，而不是在当前层挑选后面的数
对于每一层来说，不存在选和不选（位置上），只是选哪一个而已

19. 删除链表的倒数第 N 个结点
两个指针 first 和 second
first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点

22. 括号生成 ！！！！
数字n代表生成括号的对数

1、递归，子问题
2、'()' 添加在子串的各个位置
3、hash排重

31. 下一个排列
总结规律
1、从后面开始找，开始降序的第一个元素，然后找到比这个元素大的最小元素，进行交换，然后对后面的序列升序排序
2、本来是逆序的，直接一步升序处理

32. 最长有效括号
两个计数器 left 和 right
 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，记录目前为止找到的最长子字符串
 right 计数器比 left 计数器大时，我们将 left 和 right 计数器同时变回 0

33. 搜索旋转排序数组
func binarySearch(nums []int, start, end, target int) int {
二分查找是判断前半段有序还是后判断有序，再分别判断是否在有序半段内
if nums[start] <= nums[mid] {
		if target >= nums[start] && target <= nums[mid] {
			return binarySearch(nums, start, mid, target)
		}

34. 在排序数组中查找元素的第一个和最后一个位置 ！！！
非递减顺序排列的整数数组nums，和一个目标值target

二分查找中，寻找 leftIdx 即为在数组中寻找第一个小于等于 target 的下标，寻找 rightIdx 即为在数组中寻找第一个大于等于 target 的下标
在逻辑中找到target的下标并赋值，不要用等return回来的下标！！

func findBound(nums []int, target int, isFirst bool) int {
	left, right := 0, len(nums)-1
	bound := -1
	for left <= right {
		mid := (left + right)/2
		if nums[mid] == target {
			bound = mid
			if isFirst {
				// 继续往左边找
				right = mid - 1
			} else {
				// 继续往右边找
				left = mid + 1
			}
		} else if nums[mid] < target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return bound
}

42. 接雨水!!!
对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]
下标 i 处能接的雨水量由 leftMax[i] 和 rightMax[i] 中的最小值决定

双指针（左右开始往中间）
当两个指针相遇时，即可得到能接的雨水总量。
如果 `height[left]<height[right]`，则必有 `leftMax<rightMax`，下标 left 处能接的雨水量等于 leftMax−height[left] !!!!

53. 最大子数组和
子数组是数组中的一个连续部分。

动态规划，遍历过程中记录最大值
dp[i]是包含nums[i]的最优值
dp[i] = max(dp[i-1]+nums[i], nums[i])

918. 环形子数组的最大和 !!!！！！

情况1：最大子数组不跨环，即最大子数组和_test.go 无环的
情况2：最大子数组跨了环（首尾拼接）
  - 整个数组总和 - 最小连续子数组和 = 最大跨环子数组和

终极策略总结：
1. 先用 Kadane 算法求出最大子数组和：maxSubSum
2. 再用 Kadane 算法求出最小子数组和：minSubSum
3. 计算整个数组总和 totalSum
4. 答案是：
  - 如果 maxSubSum < 0：说明全是负数，只能取 maxSubSum
  - 否则，取 max(maxSubSum, totalSum - minSubSum)

62. 不同路径
一个机器人位于一个m x n网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角
dp[i][j] 表示从起点到位置 (i,j) 的不同路径数。
dp[i][j] = dp[i-1][j] + dp[i][j-1]

64. 最小路径和
 m x n 网格 grid 从左上角到右下角的路径
 // 动态规划
 // 遍历每一行，参考上和左算出最小值即可
 // 还可以优化空间复杂度为O（1），在原数组上面操作

72. 编辑距离
给你两个单词word1和word2，请返回将word1转换成word2所使用的最少操作数

//插入、删除、替换
设dp[i,j] ,表示， 长度为i的A子串 转换到 长度为j的B子串 的距离
显然，可以算出dp[0,y], dp[x,0]的距离分别是y和x

75. 颜色分类
给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums
三个数字，刚好可以使用三指针
一个指针p，left，right； p指针遍历for p<=right; left和right分别指向非0和非2的数组下标； p始终位于left和right之间，最后一个非白色下标
核心：遍历中间地带，不属于白色，往两边交换！！

79. 单词搜索
给定一个m x n二维字符网格board和一个字符串单词word
二维网格搜索 + 回溯 + DFS + 访问标记
外层以每个位置作为起点，开始递归检查

96. 不同的二叉搜索树 !!!
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种
1.递归的做法：关键核心，以不同的元素作为根元素，所组成的树是不同的
效率比较低
for i := 0; i < n; i++ {
		if i == 0 || i == n-1 {
			//最左或最右作为根结点
			num += numTrees(n - 1)
			continue
		}
		//中间结点作为根结点，左右剩余的元素
		num += numTrees(i) * numTrees(n-i-1)
	}

98. 验证二叉搜索树
用中序递归遍历，检查

101. 对称二叉树【简单】!!!
检查它是否轴对称。
栈（层序遍历）或递归
递归!!!:
check = func(left, right *TreeNode) bool {

return check(left.Left, right.Right) && check(left.Right, right.Left)
}

104. 二叉树的最大深度
栈（层序遍历）或递归
递归
dfs = func(depth int, root *TreeNode) int {

}

105. 从前序与中序遍历序列构造二叉树
1、先序的第一位即树的根结点
2、从中序中找出根结点的位置，除根结点分成两半，同时得到左树的长度
3、得到左子树长度后，也可以把先序除根结点外分成左右两半
4、递归构造左右子树

106. 从中序与后序遍历序列构造二叉树
root的在前序的第一个，在后序的最后一个

114. 二叉树展开为链表 ！！！
把左边结点放右边，右边结点放在原左结点的最后一个右结点下，然后一直递归右子树，左子树置空

124. 二叉树中的最大路径和
不一定经过根节点

递归函数maxGain只选左或右的函数（只选一边，包含root），设置一个全局变量，在递归函数内部计算root加左右的最大值

128. 最长连续序列 ！！！！
值数字之间相差1
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

0、遍历第一遍，hashmap存数字是否存在
1、遍历，从当前数逐步加一，到找不到停止，则为由当前数开始的最长
2、遍历开始前判断是否存在更小的数，由更小的数来迭代，避免重复计算

136. 只出现一次的数字
除了某个元素只出现一次以外，其余每个元素均出现两次

遍历异或运算最后的结果
