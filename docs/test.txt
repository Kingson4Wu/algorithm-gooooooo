0, 10], [8, 12], [14, 18], [19, 21], [20, 31], [21, 39], [25, 27], [28, 30], [31, 35




# 复习点
！！！为重点看

3. 最长不含重复字符的子字符串
双指针（即滑动窗口）+ hashmap

76. 最小覆盖子串
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
滑动窗口（增加队列，保存下一次的滑动窗口的left）
hashmap 计算满足的数量 提示判断效率

5. 最长回文子串
(动态规划)
用 P(i,j) 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成 s[i:j]）是否为回文串

11. 盛最多水的容器 ！！！
【两根柱子组成的最大面积！！！】
【左右两个指针，小的先移动（为了寻找更大的）】

计算两边指针的最大容量（取决于矮的那个） - 左右指针对比，移动高度更小的指针
left, right := 0, len(height)-1
for left < right {

15. 三数之和 ！！！
返回所有和为 0 且不重复的三元组。

排序+双指针！！！

【双循环】
【遍历，选i为第一个】
【i的右边的区间，设左右指针，找出剩下两个的所有组合】
【i的数值有重复跳过，另外两个数有重复的跳过】
 if i > 0 && nums[i] == nums[i-1] {
 for left < right {
 for left < right && nums[left] == nums[left+1] {
     left++
 }
 for left < right && nums[right] == nums[right-1] {
     right--
 }

1、先排序，从小到大！！！
2、遍历nums选中i作为第一个数，其他的从这个数的右边找，左右两边双指针往中间计算（left, right := i+1, len(nums)-1）
3、注意计算结果不重复，需对一些条件跳过当前循环

17. 电话号码的字母组合
构造性DFS → 不需要 for 循环
每一层只能处理一个位置的选项，只做一位，而不是在当前层挑选后面的数
对于每一层来说，不存在选和不选（位置上），只是选哪一个而已

19. 删除链表的倒数第 N 个结点
两个指针 first 和 second
first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点

22. 括号生成 ！！！！
数字n代表生成括号的对数

1、递归，子问题
2、'()' 添加在子串的各个位置
3、hash排重

31. 下一个排列
总结规律
1、从后面开始找，开始降序的第一个元素，然后找到比这个元素大的最小元素，进行交换，然后对后面的序列升序排序
2、本来是逆序的，直接一步升序处理

32. 最长有效括号
两个计数器 left 和 right
 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，记录目前为止找到的最长子字符串
 right 计数器比 left 计数器大时，我们将 left 和 right 计数器同时变回 0

33. 搜索旋转排序数组
func binarySearch(nums []int, start, end, target int) int {
二分查找是判断前半段有序还是后判断有序，再分别判断是否在有序半段内
if nums[start] <= nums[mid] {
		if target >= nums[start] && target <= nums[mid] {
			return binarySearch(nums, start, mid, target)
		}

34. 在排序数组中查找元素的第一个和最后一个位置 ！！！
非递减顺序排列的整数数组nums，和一个目标值target

二分查找中，寻找 leftIdx 即为在数组中寻找第一个小于等于 target 的下标，寻找 rightIdx 即为在数组中寻找第一个大于等于 target 的下标
在逻辑中找到target的下标并赋值，不要用等return回来的下标！！

func findBound(nums []int, target int, isFirst bool) int {
	left, right := 0, len(nums)-1
	bound := -1
	for left <= right {
		mid := (left + right)/2
		if nums[mid] == target {
			bound = mid
			if isFirst {
				// 继续往左边找
				right = mid - 1
			} else {
				// 继续往右边找
				left = mid + 1
			}
		} else if nums[mid] < target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return bound
}

42. 接雨水!!!
对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]
下标 i 处能接的雨水量由 leftMax[i] 和 rightMax[i] 中的最小值决定

双指针（左右开始往中间）
当两个指针相遇时，即可得到能接的雨水总量。
如果 `height[left]<height[right]`，则必有 `leftMax<rightMax`，下标 left 处能接的雨水量等于 leftMax−height[left] !!!!

53. 最大子数组和
子数组是数组中的一个连续部分。

动态规划，遍历过程中记录最大值
dp[i]是包含nums[i]的最优值
dp[i] = max(dp[i-1]+nums[i], nums[i])

918. 环形子数组的最大和 !!!！！！

情况1：最大子数组不跨环，即最大子数组和_test.go 无环的
情况2：最大子数组跨了环（首尾拼接）
  - 整个数组总和 - 最小连续子数组和 = 最大跨环子数组和

终极策略总结：
1. 先用 Kadane 算法求出最大子数组和：maxSubSum
2. 再用 Kadane 算法求出最小子数组和：minSubSum
3. 计算整个数组总和 totalSum
4. 答案是：
  - 如果 maxSubSum < 0：说明全是负数，只能取 maxSubSum
  - 否则，取 max(maxSubSum, totalSum - minSubSum)

62. 不同路径
一个机器人位于一个m x n网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角
dp[i][j] 表示从起点到位置 (i,j) 的不同路径数。
dp[i][j] = dp[i-1][j] + dp[i][j-1]

64. 最小路径和
 m x n 网格 grid 从左上角到右下角的路径
 // 动态规划
 // 遍历每一行，参考上和左算出最小值即可
 // 还可以优化空间复杂度为O（1），在原数组上面操作

72. 编辑距离
给你两个单词word1和word2，请返回将word1转换成word2所使用的最少操作数

//插入、删除、替换
设dp[i,j] ,表示， 长度为i的A子串 转换到 长度为j的B子串 的距离
显然，可以算出dp[0,y], dp[x,0]的距离分别是y和x

75. 颜色分类
给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums
三个数字，刚好可以使用三指针
一个指针p，left，right； p指针遍历for p<=right; left和right分别指向非0和非2的数组下标； p始终位于left和right之间，最后一个非白色下标
核心：遍历中间地带，不属于白色，往两边交换！！

79. 单词搜索
给定一个m x n二维字符网格board和一个字符串单词word
二维网格搜索 + 回溯 + DFS + 访问标记
外层以每个位置作为起点，开始递归检查

96. 不同的二叉搜索树 !!!
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种
1.递归的做法：关键核心，以不同的元素作为根元素，所组成的树是不同的
效率比较低
for i := 0; i < n; i++ {
		if i == 0 || i == n-1 {
			//最左或最右作为根结点
			num += numTrees(n - 1)
			continue
		}
		//中间结点作为根结点，左右剩余的元素
		num += numTrees(i) * numTrees(n-i-1)
	}

98. 验证二叉搜索树
用中序递归遍历，检查

101. 对称二叉树【简单】!!!
检查它是否轴对称。
栈（层序遍历）或递归
递归!!!:
check = func(left, right *TreeNode) bool {

return check(left.Left, right.Right) && check(left.Right, right.Left)
}

104. 二叉树的最大深度
栈（层序遍历）或递归
递归
dfs = func(depth int, root *TreeNode) int {

}

105. 从前序与中序遍历序列构造二叉树
1、先序的第一位即树的根结点
2、从中序中找出根结点的位置，除根结点分成两半，同时得到左树的长度
3、得到左子树长度后，也可以把先序除根结点外分成左右两半
4、递归构造左右子树

106. 从中序与后序遍历序列构造二叉树
root的在前序的第一个，在后序的最后一个

114. 二叉树展开为链表 ！！！
把左边结点放右边，右边结点放在原左结点的最后一个右结点下，然后一直递归右子树，左子树置空

124. 二叉树中的最大路径和
不一定经过根节点

递归函数maxGain只选左或右的函数（只选一边，包含root），设置一个全局变量，在递归函数内部计算root加左右的最大值

128. 最长连续序列 ！！！！
值数字之间相差1
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

0、遍历第一遍，hashmap存数字是否存在
1、遍历，从当前数逐步加一，到找不到停止，则为由当前数开始的最长
2、遍历开始前判断是否存在更小的数，由更小的数来迭代，避免重复计算

136. 只出现一次的数字
除了某个元素只出现一次以外，其余每个元素均出现两次

遍历异或运算最后的结果

139. 单词拆分 !!!
给你一个字符串s和一个字符串列表wordDict作为字典。如果可以利用字典中出现的一个或多个单词拼接出s则返回true。
注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

dp[i]
s中以i结尾, 子串是0...j

1、构造一个单词的hashmap
2、双重循环查询是否存在
if dp[j] && wordDictSet[s[j:i]]
    dp[i] = true

140. 单词拆分 II !!!
回溯（dfs中遍历选择）

输入:s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]
输出:["cats and dog","cat sand dog"]

跟131. 分割回文串_test.go（中等题）一样的套路，为啥是困难题？？？
回溯

148. 排序链表
总体思想，分治和归并排序
定义merge函数，用于两两合并已排序的链表

写起来太恶心

152. 乘积最大子数组 ！！！
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组

用max_dp[i]表示以第 i 个元素结尾的最大乘积 ！！！！
用min_dp[i]表示以第 i 个元素结尾的最小乘积（因为可能是负的）！！！！！
max_dp[i] = max( max_dp[i-1] * num[i], min_dp[i] * num[i], num[i])
min_dp[i] = min( max_dp[i-1] * num[i], min_dp[i] * num[i], num[i])
一次遍历接口算出来
只用三个变量即可 ！！！！
minF, maxF, maxVal := nums[0], nums[0], nums[0]

155. 最小栈
在栈的基础上，增加同样大小的辅助栈，用于记录当前的最小值
相当于每次push的时候，都记录当前快照下的最小值

169. 多数元素 !!!
给定一个大小为n的数组nums，返回其中的多数元素。多数元素是指在数组中出现次数大于⌊ n/2 ⌋的元素。

对数字进行计数，相同加1，不同减一
根据题目的前提条件，多数元素大于【n/2】，那么最后存在的那个数一定是多数元素

200. 岛屿数量
无向图深度优先搜索
将1变成0的过程相当于标记visited
遍历所有结点，是1的统计加1，深度搜索将周围的1全变成0，最后统计出来的count即岛屿数量

208. 实现 Trie (前缀树) !!!!
1、Trie 使用一个数组记录全部字母对应的下一个Trie， 还有一个标志位记录是否结尾；
（其实就是一个树，根节点是一个26个字母(大小写)组成的数组 ！！, 如果有更多字符，可以使用map代替）
2、利用ch - 'A' < 26 的特性

type Trie struct {
	words [26]*Trie
	isEnd bool
}

221. 最大正方形
在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。

动态规划
dp(i,j)表示以 (i,j) 为右下角，且只包含 1 的正方形的边长最大值
dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1

dp[y][x] = min(min(dp[y][x-1], dp[y-1][x]), dp[y-1][x-1]) + 1

236. 二叉树的最近公共祖先 !!!!!

root等于left或right的val其中一个就返回
递归left和right都返回空，则返回root，否则返回不为空的那个

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {

	if root == nil {
		return nil
	}

	if root.Val == p.Val || root.Val == q.Val {
		return root
	}

	left := lowestCommonAncestor(root.Left, p, q)
	right := lowestCommonAncestor(root.Right, p, q)

	if left == nil {
		return right
	}

	if right == nil {
		return left
	}

	return root
}
```

238. 除自身以外数组的乘积 !!!
给你一个整数数组nums，返回 数组answer，其中answer[i]等于nums中除nums[i]之外其余各元素的乘积。

利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案
空间复杂度 O(1)的方法
```go
/** 算出i左边的乘积 */
	ans[0] = 1
	for i := 1; i < len(nums); i++ {
		ans[i] = nums[i-1] * ans[i-1]
	}
	/** 和右边相乘 */
	right := 1
	for i := len(nums) - 1; i >= 0; i-- {
		ans[i] = ans[i] * right
		right *= nums[i]
	}
```

239. 滑动窗口最大值 [困难] !!!!
给你一个整数数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]

单调队列（按数值单调递减，存下标）
当滑动窗口向右移动时， i<j, 如果 nums[i]≤nums[j]， 那么可以删除nums[i]
使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组 nums 中对应的值是严格单调递减的
遍历元素，先push进队列，然后比对队列从0开始下标是否符合窗口，不符合删除，队列是按数值单调递减的

push队列方法：去掉和新元素不能保持单调递增的元素下标： queue = queue[:len(queue)-1] 删队尾
遍历时：判断下标是不是不符合窗口 queue = queue[1:] 删队头

74. 搜索二维矩阵
二维转一维，二分查找

240. 搜索二维矩阵 II  ！！！！！
* 每行的元素从左到右升序排列。
* 每列的元素从上到下升序排列。

使用Z字型的搜索策略，从右上角开始（左边小下边大）
注意横坐标左移是j--
for i < len(matrix) && j >= 0 {

279. 完全平方数 !!!!
给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
输入：n = 12
输出：3
解释：12 = 4 + 4 + 4

动态规划
dp[i] 表示最少需要多少个数的平方来表示整数 i
双重循环计算

```go
func numSquares(n int) int {

	dp := make([]int, n+1)

	for i := 1; i <= n; i++ {
		for j := 1; j <= n; j++ {
			s := j * j
			if s > i {
				break
			}
			if dp[i] == 0 || dp[i] > dp[i-s]+1 {
				dp[i] = dp[i-s] + 1
			}
		}
	}
	return dp[n]
}
```

287. 寻找重复数 ！！！！

给定一个包含n + 1个整数的数组nums，其数字都在[1, n]范围内（包括1和n），可知至少存在一个重复的整数。

推荐使用Floyd 判圈算法, 和双向链表判断入环点一样,根据这道题的特点,其实就是一个有环的链表
快慢指针第一次相遇之后，把其中一个指针置为起始点，第二次相遇时就是环的入口

297. 二叉树的序列化与反序列化
使用先序来序列化和反序列化！！！
1、使用“null”表示结点为空
2、使用递归
3、使用全局变量！！！简化递归的传参问题！！要记住递归运行时也是串行的！！
4、序列化和反序列话都在内部定一个方法来递归，序列化的全局变量用来构造结果，反序列化的全局变量用来消耗。
序列化的全局变量： var result []string； 内部递归方法：var serialize func(*TreeNode)
反序列化的全局变量： result := strings.Split(data, ",") ；内部递归方法：var deserialize func() *TreeNode

300. 最长递增子序列 !!!
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
输入：nums = [7,7,7,7,7,7,7]
输出：1

动态规划
定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。
dp[i]=max(dp[j])+1,其中0≤j<i 且 num[j]<num[i]

