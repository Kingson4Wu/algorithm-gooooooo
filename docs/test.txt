0, 10], [8, 12], [14, 18], [19, 21], [20, 31], [21, 39], [25, 27], [28, 30], [31, 35




# 复习点
！！！为重点看

3. 最长不含重复字符的子字符串
双指针（即滑动窗口）+ hashmap

76. 最小覆盖子串
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
滑动窗口（增加队列，保存下一次的滑动窗口的left）
hashmap 计算满足的数量 提示判断效率

438. 找到字符串中所有字母异位词
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
滑动窗口+hash表
记录map的数量，而不是每次遍历比对

5. 最长回文子串
(动态规划)
用 P(i,j) 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成 s[i:j]）是否为回文串

11. 盛最多水的容器 ！！！
【两根柱子组成的最大面积！！！】
【左右两个指针，小的先移动（为了寻找更大的）】

计算两边指针的最大容量（取决于矮的那个） - 左右指针对比，移动高度更小的指针
left, right := 0, len(height)-1
for left < right {

15. 三数之和 ！！！
返回所有和为 0 且不重复的三元组。

排序+双指针！！！

【双循环】
【遍历，选i为第一个】
【i的右边的区间，设左右指针，找出剩下两个的所有组合】
【i的数值有重复跳过，另外两个数有重复的跳过】
 if i > 0 && nums[i] == nums[i-1] {
 for left < right {
 for left < right && nums[left] == nums[left+1] {
     left++
 }
 for left < right && nums[right] == nums[right-1] {
     right--
 }

1、先排序，从小到大！！！
2、遍历nums选中i作为第一个数，其他的从这个数的右边找，左右两边双指针往中间计算（left, right := i+1, len(nums)-1）
3、注意计算结果不重复，需对一些条件跳过当前循环

17. 电话号码的字母组合
构造性DFS → 不需要 for 循环
每一层只能处理一个位置的选项，只做一位，而不是在当前层挑选后面的数
对于每一层来说，不存在选和不选（位置上），只是选哪一个而已

19. 删除链表的倒数第 N 个结点
两个指针 first 和 second
first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点

22. 括号生成 ！！！！
数字n代表生成括号的对数

1、递归，子问题
2、'()' 添加在子串的各个位置
3、hash排重

31. 下一个排列
总结规律
1、从后面开始找，开始降序的第一个元素，然后找到比这个元素大的最小元素，进行交换，然后对后面的序列升序排序
2、本来是逆序的，直接一步升序处理

32. 最长有效括号
两个计数器 left 和 right
 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，记录目前为止找到的最长子字符串
 right 计数器比 left 计数器大时，我们将 left 和 right 计数器同时变回 0

33. 搜索旋转排序数组
func binarySearch(nums []int, start, end, target int) int {
二分查找是判断前半段有序还是后判断有序，再分别判断是否在有序半段内
if nums[start] <= nums[mid] {
		if target >= nums[start] && target <= nums[mid] {
			return binarySearch(nums, start, mid, target)
		}

34. 在排序数组中查找元素的第一个和最后一个位置 ！！！
非递减顺序排列的整数数组nums，和一个目标值target

二分查找中，寻找 leftIdx 即为在数组中寻找第一个小于等于 target 的下标，寻找 rightIdx 即为在数组中寻找第一个大于等于 target 的下标
在逻辑中找到target的下标并赋值，不要用等return回来的下标！！

func findBound(nums []int, target int, isFirst bool) int {
	left, right := 0, len(nums)-1
	bound := -1
	for left <= right {
		mid := (left + right)/2
		if nums[mid] == target {
			bound = mid
			if isFirst {
				// 继续往左边找
				right = mid - 1
			} else {
				// 继续往右边找
				left = mid + 1
			}
		} else if nums[mid] < target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return bound
}

42. 接雨水!!!
对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]
下标 i 处能接的雨水量由 leftMax[i] 和 rightMax[i] 中的最小值决定

双指针（左右开始往中间）
当两个指针相遇时，即可得到能接的雨水总量。
如果 `height[left]<height[right]`，则必有 `leftMax<rightMax`，下标 left 处能接的雨水量等于 leftMax−height[left] !!!!

53. 最大子数组和
子数组是数组中的一个连续部分。

动态规划，遍历过程中记录最大值
dp[i]是包含nums[i]的最优值
dp[i] = max(dp[i-1]+nums[i], nums[i])

918. 环形子数组的最大和 !!!！！！

情况1：最大子数组不跨环，即最大子数组和_test.go 无环的
情况2：最大子数组跨了环（首尾拼接）
  - 整个数组总和 - 最小连续子数组和 = 最大跨环子数组和

终极策略总结：
1. 先用 Kadane 算法求出最大子数组和：maxSubSum
2. 再用 Kadane 算法求出最小子数组和：minSubSum
3. 计算整个数组总和 totalSum
4. 答案是：
  - 如果 maxSubSum < 0：说明全是负数，只能取 maxSubSum
  - 否则，取 max(maxSubSum, totalSum - minSubSum)

62. 不同路径
一个机器人位于一个m x n网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角
dp[i][j] 表示从起点到位置 (i,j) 的不同路径数。
dp[i][j] = dp[i-1][j] + dp[i][j-1]

64. 最小路径和
 m x n 网格 grid 从左上角到右下角的路径
 // 动态规划
 // 遍历每一行，参考上和左算出最小值即可
 // 还可以优化空间复杂度为O（1），在原数组上面操作

72. 编辑距离
给你两个单词word1和word2，请返回将word1转换成word2所使用的最少操作数

//插入、删除、替换
设dp[i,j] ,表示， 长度为i的A子串 转换到 长度为j的B子串 的距离
显然，可以算出dp[0,y], dp[x,0]的距离分别是y和x

75. 颜色分类
给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums
三个数字，刚好可以使用三指针
一个指针p，left，right； p指针遍历for p<=right; left和right分别指向非0和非2的数组下标； p始终位于left和right之间，最后一个非白色下标
核心：遍历中间地带，不属于白色，往两边交换！！

79. 单词搜索
给定一个m x n二维字符网格board和一个字符串单词word
二维网格搜索 + 回溯 + DFS + 访问标记
外层以每个位置作为起点，开始递归检查

96. 不同的二叉搜索树 !!!
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种
1.递归的做法：关键核心，以不同的元素作为根元素，所组成的树是不同的
效率比较低
for i := 0; i < n; i++ {
		if i == 0 || i == n-1 {
			//最左或最右作为根结点
			num += numTrees(n - 1)
			continue
		}
		//中间结点作为根结点，左右剩余的元素
		num += numTrees(i) * numTrees(n-i-1)
	}

98. 验证二叉搜索树
用中序递归遍历，检查

101. 对称二叉树【简单】!!!
检查它是否轴对称。
栈（层序遍历）或递归
递归!!!:
check = func(left, right *TreeNode) bool {

return check(left.Left, right.Right) && check(left.Right, right.Left)
}

104. 二叉树的最大深度
栈（层序遍历）或递归
递归
dfs = func(depth int, root *TreeNode) int {

}

105. 从前序与中序遍历序列构造二叉树
1、先序的第一位即树的根结点
2、从中序中找出根结点的位置，除根结点分成两半，同时得到左树的长度
3、得到左子树长度后，也可以把先序除根结点外分成左右两半
4、递归构造左右子树

106. 从中序与后序遍历序列构造二叉树
root的在前序的第一个，在后序的最后一个

114. 二叉树展开为链表 ！！！
把左边结点放右边，右边结点放在原左结点的最后一个右结点下，然后一直递归右子树，左子树置空

124. 二叉树中的最大路径和
不一定经过根节点

递归函数maxGain只选左或右的函数（只选一边，包含root），设置一个全局变量，在递归函数内部计算root加左右的最大值

128. 最长连续序列 ！！！！
值数字之间相差1
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

0、遍历第一遍，hashmap存数字是否存在
1、遍历，从当前数逐步加一，到找不到停止，则为由当前数开始的最长
2、遍历开始前判断是否存在更小的数，由更小的数来迭代，避免重复计算

136. 只出现一次的数字
除了某个元素只出现一次以外，其余每个元素均出现两次

遍历异或运算最后的结果

139. 单词拆分 !!!
给你一个字符串s和一个字符串列表wordDict作为字典。如果可以利用字典中出现的一个或多个单词拼接出s则返回true。
注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

dp[i]
s中以i结尾, 子串是0...j

1、构造一个单词的hashmap
2、双重循环查询是否存在
if dp[j] && wordDictSet[s[j:i]]
    dp[i] = true

140. 单词拆分 II !!!
回溯（dfs中遍历选择）

输入:s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]
输出:["cats and dog","cat sand dog"]

跟131. 分割回文串_test.go（中等题）一样的套路，为啥是困难题？？？
回溯

148. 排序链表
总体思想，分治和归并排序
定义merge函数，用于两两合并已排序的链表

写起来太恶心

152. 乘积最大子数组 ！！！
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组

用max_dp[i]表示以第 i 个元素结尾的最大乘积 ！！！！
用min_dp[i]表示以第 i 个元素结尾的最小乘积（因为可能是负的）！！！！！
max_dp[i] = max( max_dp[i-1] * num[i], min_dp[i] * num[i], num[i])
min_dp[i] = min( max_dp[i-1] * num[i], min_dp[i] * num[i], num[i])
一次遍历接口算出来
只用三个变量即可 ！！！！
minF, maxF, maxVal := nums[0], nums[0], nums[0]

155. 最小栈
在栈的基础上，增加同样大小的辅助栈，用于记录当前的最小值
相当于每次push的时候，都记录当前快照下的最小值

169. 多数元素 !!!
给定一个大小为n的数组nums，返回其中的多数元素。多数元素是指在数组中出现次数大于⌊ n/2 ⌋的元素。

对数字进行计数，相同加1，不同减一
根据题目的前提条件，多数元素大于【n/2】，那么最后存在的那个数一定是多数元素

200. 岛屿数量
无向图深度优先搜索
将1变成0的过程相当于标记visited
遍历所有结点，是1的统计加1，深度搜索将周围的1全变成0，最后统计出来的count即岛屿数量

208. 实现 Trie (前缀树) !!!!
1、Trie 使用一个数组记录全部字母对应的下一个Trie， 还有一个标志位记录是否结尾；
（其实就是一个树，根节点是一个26个字母(大小写)组成的数组 ！！, 如果有更多字符，可以使用map代替）
2、利用ch - 'A' < 26 的特性

type Trie struct {
	words [26]*Trie
	isEnd bool
}

221. 最大正方形
在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。

动态规划
dp(i,j)表示以 (i,j) 为右下角，且只包含 1 的正方形的边长最大值
dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1

dp[y][x] = min(min(dp[y][x-1], dp[y-1][x]), dp[y-1][x-1]) + 1

236. 二叉树的最近公共祖先 !!!!!

root等于left或right的val其中一个就返回
递归left和right都返回空，则返回root，否则返回不为空的那个

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {

	if root == nil {
		return nil
	}

	if root.Val == p.Val || root.Val == q.Val {
		return root
	}

	left := lowestCommonAncestor(root.Left, p, q)
	right := lowestCommonAncestor(root.Right, p, q)

	if left == nil {
		return right
	}

	if right == nil {
		return left
	}

	return root
}
```

238. 除自身以外数组的乘积 !!!
给你一个整数数组nums，返回 数组answer，其中answer[i]等于nums中除nums[i]之外其余各元素的乘积。

利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案
空间复杂度 O(1)的方法
```go
/** 算出i左边的乘积 */
	ans[0] = 1
	for i := 1; i < len(nums); i++ {
		ans[i] = nums[i-1] * ans[i-1]
	}
	/** 和右边相乘 */
	right := 1
	for i := len(nums) - 1; i >= 0; i-- {
		ans[i] = ans[i] * right
		right *= nums[i]
	}
```

239. 滑动窗口最大值 [困难] !!!!
给你一个整数数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]

单调队列（按数值单调递减，存下标）
当滑动窗口向右移动时， i<j, 如果 nums[i]≤nums[j]， 那么可以删除nums[i]
使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组 nums 中对应的值是严格单调递减的
遍历元素，先push进队列，然后比对队列从0开始下标是否符合窗口，不符合删除，队列是按数值单调递减的

push队列方法：去掉和新元素不能保持单调递增的元素下标： queue = queue[:len(queue)-1] 删队尾
遍历时：判断下标是不是不符合窗口 queue = queue[1:] 删队头

74. 搜索二维矩阵
二维转一维，二分查找

240. 搜索二维矩阵 II  ！！！！！
* 每行的元素从左到右升序排列。
* 每列的元素从上到下升序排列。

使用Z字型的搜索策略，从右上角开始（左边小下边大）
注意横坐标左移是j--
for i < len(matrix) && j >= 0 {

279. 完全平方数 !!!!
给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
输入：n = 12
输出：3
解释：12 = 4 + 4 + 4

动态规划
dp[i] 表示最少需要多少个数的平方来表示整数 i
双重循环计算

```go
func numSquares(n int) int {

	dp := make([]int, n+1)

	for i := 1; i <= n; i++ {
		for j := 1; j <= n; j++ {
			s := j * j
			if s > i {
				break
			}
			if dp[i] == 0 || dp[i] > dp[i-s]+1 {
				dp[i] = dp[i-s] + 1
			}
		}
	}
	return dp[n]
}
```

287. 寻找重复数 ！！！！

给定一个包含n + 1个整数的数组nums，其数字都在[1, n]范围内（包括1和n），可知至少存在一个重复的整数。

推荐使用Floyd 判圈算法, 和双向链表判断入环点一样,根据这道题的特点,其实就是一个有环的链表
快慢指针第一次相遇之后，把其中一个指针置为起始点，第二次相遇时就是环的入口

297. 二叉树的序列化与反序列化
使用先序来序列化和反序列化！！！
1、使用“null”表示结点为空
2、使用递归
3、使用全局变量！！！简化递归的传参问题！！要记住递归运行时也是串行的！！
4、序列化和反序列话都在内部定一个方法来递归，序列化的全局变量用来构造结果，反序列化的全局变量用来消耗。
序列化的全局变量： var result []string； 内部递归方法：var serialize func(*TreeNode)
反序列化的全局变量： result := strings.Split(data, ",") ；内部递归方法：var deserialize func() *TreeNode

300. 最长递增子序列 !!!
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
输入：nums = [7,7,7,7,7,7,7]
输出：1

动态规划
定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。
dp[i]=max(dp[j])+1,其中0≤j<i 且 num[j]<num[i]

301. 删除无效的括号[困难] !!!

方法一：回溯 + 剪枝
1、定义一个函数判断最终的字符串是否是有效括号的字符串
2、先计算总共最少需要删除的左括号和右括号分别的个数（题目就是要求删除最少）
3、深度遍历加回溯，删除左右括号，然后判断是否是有效括号的字符串
	- dfs func(s string, start, lRemove, rRemove int)
	- 删够字符的，且是合法字符串，直接添加到结果并返回
	- 遍历选择删除的字符
		- 相同的左括号或右括号（连续），注意剪枝
		- 如果剩余的字符无法满足去掉的数量要求，直接返回
		- 删除左括号，并递归删除下一个字符
		- 删除右括号，并递归删除下一个字符

312. 戳气球【困难】!!!!
戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1]枚硬币。

动态规划
首尾各添加一个元素1，方便计算，创建n+2的dp
dp[i][j] = x 表示，戳破气球 i 和气球 j 之间（开区间，不包括 i 和 j）的所有气球，可以获得的最高分数为 x。 !!!!
dp[i][j]= max(val[i]×val[k]×val[j] + dp[i][k] + dp[k][j]), （i+1 < k < j-1） (i < j-1) !!!!
dp[i][j]= 0, （i+1 < k < j-1） (i >= j-1)
最终答案即为 dp[0][n+1]

(n-1, n) 是一个空区间（n-1+1 == n，没有气球可以戳），所以其值一定是 0，即默认值。

338. 比特位计数 !!!!
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10

动态规划——最低有效位
dp[i] = dp[i>>1] + i&1
dp[i] 的值等于 dp[i>>1] 的值加上 i 除以 2 的余数(即i&1)。!!!!

347. 前 K 个高频元素
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]

用hashmap记录数字和对应的出现个数
因为是前k个，使用快排即可，不过快排最差时间n的平方 !!

394. 字符串解码
输入：s = "3[a]2[bc]"
输出："aaabcbc"

双栈法
栈保存重复的次数(数字前缀)
对应的栈下标的辅助栈保存将要重复的字符串
遇到'['入栈，遇到']'出栈， 出栈 追加到 栈顶 次数对应的辅助栈 的前缀字符串，如果栈为空，则追加到最终的结果字符串

399. 除法求值
有向图遍历
双向保存除法的分母分子映射以及对应的数据， val、 1/val， 保存在同个map， 另外一个对应的val map作为计算辅助
递归有向图遍历，visited标记， 回溯维护val列表值（全局变量）

406. 根据身高重建队列 !!!
每个people[i] = [hi, ki]表示第i个人的身高为hi，前面正好有ki个身高大于或等于hi的人

1、先按第一个数据按高到低排序（身高从大到小排，身高相同的k小的排前面）
2、遍历将元素插入到前面合适的位置（排完序高的都在前面，后面矮的往前面插对已经排好的高的都没影响！！！！）
(注意一定有答案，所以不用双重遍历，直接使用第二个下标可以拼接！！！)
result = append(result[:index], append([][]int{person}, result[index:]...)...) !!!!

437. 路径总和 III ！！！！！！
求该二叉树里节点值之和等于targetSum的路径的数目。
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）
不能左右都包括！


新增一个一定包含root的辅助方法来递归
主方法递归，辅助方法也递归

```go
func pathSum(root *TreeNode, targetSum int) int {

	if root == nil {
		return 0
	}

	return paths(root, targetSum) + pathSum(root.Left, targetSum) + pathSum(root.Right, targetSum)
}

/*
*
一定包括root的情况
*/
func paths(root *TreeNode, targetSum int) int {

	if root == nil {
		return 0
	}

	count := 0
	if root.Val == targetSum {
		count = 1
	}
	return count + paths(root.Left, targetSum-root.Val) + paths(root.Right, targetSum-root.Val)
}
```
448. 找到所有数组中消失的数字
nums[i]在区间[1, n]内

利用负数
遍历第一遍，将存在的数字对应的下标的数字变成负的
遍历第二遍，统计数字大于0的下标，即不存在的数字

494. 目标和
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
。。。
递归或回溯
回溯可以加memo来兼枝加快速度

538. 把二叉搜索树转换为累加树
用中序的倒序来递归遍历累加

543. 二叉树的直径！！！

等于求左右深度之和！！！！
定义一个树深度的递归函数，用后序遍历，在遍历中顺带计算每个节点的深度，并更新最大直径，只遍历一次！！

```go
func diameterOfBinaryTree(root *TreeNode) int {
    maxDiameter := 0

    var depth func(node *TreeNode) int
    depth = func(node *TreeNode) int {
        if node == nil {
            return 0
        }
        left := depth(node.Left)
        right := depth(node.Right)

        // 更新最大直径，边数 = left + right（不加1）
        maxDiameter = max(maxDiameter, left + right)

        return 1 + max(left, right)
    }

    depth(root)
    return maxDiameter
}
```

560. 和为 K 的子数组 !!!!!!!

输入：nums = [1,1,1], k = 2
输出：2

使用hash保存前缀和
即双重循环中可以复用之前的计算结果

定义pre[i]为[0...i]里所有数的和，则pre[i]可以由pre[i-1]递推而来，即：pre[i] = pre[i-1] + nums[i],那么[j...i]这个子数组和为k这个条件可以转化为 pre[i] - pre[j-1] == k,移项之后可的符合条件的下标需要满足pre[j-1]=pre[i]-k.
map存前缀和的次数。count是满足的连续子数组的个数。每次遍历，更新前缀和，如果前缀和减去目标和出现在map中，count则加上满足的次数。

```go
func subarraySum(nums []int, k int) int {

	/** 前缀和数量保存 */
	// 以0...i的和，从下标0开始
	m := make(map[int]int)
	count := 0

	pre := 0
	//空数组满足条件，和为0
	m[0] = 1
	for i := 0; i < len(nums); i++ {
		pre += nums[i]
		m[pre]++
		// pre 是 0...i的和；pre - k 符合条件，说明有m[pre-k] 个 0...j符合条件，对应极有m[pre-k]个 j...i的子数组符合和为k
        //想象你走路，一步一步加距离（就是前缀和），
        //你每次停下来看后面哪些“过去的脚印”（前缀和）和你现在的距离差是 `k`，
        // 如果这些脚印有两个，那就说明有两段不同的路径正好是长度 `k`，你就该加上 2。
        // 因为i是变化的
		count += m[pre-k]
	}
	return count
}
```
581. 最短无序连续子数组 ！！！！！
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序

找出中间段的左右边界
先从左到右找中间段的右下标（即遍历过程中最后一个小于左边最大值的）right （9< 10）
再找出从右到左中间段的左下标（即遍历过程中最后一个大于右边最小值的）left (6> 4)
right-left +1 即结果

739. 每日温度

answer[i]是指对于第i天，下一个更高温度出现在几天后

输入: temperatures = [73,74,75,71,69,72,76,73]
输出:[1,1,4,2,1,1,0,0]

方法二：单调栈
可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。
计数就是两个下标相减 就是结果

621. 任务调度器 

冷却时间n
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8

最大堆, 保存所有的任务，按任务数量排序
执行后放入N大的数组，后续执行任务时 任务轮次%n 得到对应的下标（冷却够时间的任务），先入堆

84. 柱状图中最大的矩形 ！！！！

单调栈 + 哨兵法
单调栈（存下标，高度值是单调递增）

用栈保存递增的柱子下标，当遇到更矮的柱子时，开始出栈并计算以弹出柱子为高的最大面积，直到单调性恢复。
	// 在头尾添加两个哨兵，避免特殊情况处理
	heights = append([]int{0}, heights...)
	heights = append(heights, 0)

w := i - stack[len(stack)-1] - 1 ！！！！！这个下标计算，画图才清楚，否则只能背了！！！！
// stack[len(stack)-1] 是在出栈之后访问的 → 实际上是原来的 stack[len(stack)-2]。

```go
func largestRectangleArea(heights []int) int {
	// 在头尾添加两个哨兵，避免特殊情况处理
	heights = append([]int{0}, heights...)
	heights = append(heights, 0)
	//前哨兵 0	数组头部	保证栈底永不为空，简化边界处理
	//后哨兵 0	数组尾部	强制触发清空栈，确保计算所有可能的最大矩形

	stack := []int{} // 存的是下标
	maxArea := 0

	for i := 0; i < len(heights); i++ {
		for len(stack) > 0 && heights[i] < heights[stack[len(stack)-1]] {
			h := heights[stack[len(stack)-1]]
			stack = stack[:len(stack)-1]
			w := i - stack[len(stack)-1] - 1
			// stack[len(stack)-1] 是在出栈之后访问的 → 实际上是原来的 stack[len(stack)-2]。
            //其实算的是上一个的面积
			maxArea = max(maxArea, h*w)
		}
		stack = append(stack, i)
	}
	return maxArea
}
```

85. 最大矩形 ！！
给定一个仅包含0和1、大小为rows x cols的二维二进制矩阵，找出只包含1的最大矩形
单调栈 + 柱状图
将每一行看作是 “柱状图” 的底边（类似于「84. 柱状图中最大矩形」），往上堆积，构建高度数组，然后在每一层使用单调栈求柱状图最大矩形面积。

对每一行 i：
若 matrix[i][j] == '1'，则 heights[j] += 1
否则，heights[j] = 0（清零）

122. 买卖股票的最佳时机 II
因为交易次数不受限，如果可以把所有的升序的全部收集到，一定是利益最大化的
if prices[i] > prices[i-1] {
	ans += prices[i] - prices[i-1]
}

274. H 指数 !!!

citations[i] 表示研究者的第 i 篇论文被引用的次数
h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最大的那个。
输入：citations = [3,0,6,1,5]
输出：3

stat[i]表示引用次数超过或等于i的有多少篇
stat := make([]int, len(citations)+1)； 使用数组作为hashmap，下标不超过citations长度（因为一篇论文被引用再多，H指数也不会超过论文总数量）
最后从后往前统计stat 即可
```go
	for i := len(stat) - 1; i > 0; i-- {
		if stat[i] >= i {
			h = i
			break
		} else {
			stat[i-1] += stat[i]
		}
	}
```

275. H 指数 II
citations 已经按照 非降序排列

排序后，我们只要找最大的 h，使得前 h 篇论文都被引用了至少 h 次。!!!!

```go
func hIndex(citations []int) int {
	h := 0
	for i := len(citations) - 1; i >= 0; i-- {
		if citations[i] > h {
			h++
		} else {
			break
		}
	}
	return h
}
```

134. 加油站！！！

从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。
如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。

一句话概括：如果x到达不了y+1，那么x-y之间的点也不可能到达y+1，因为中间任何一点的油都是拥有前面的余量的，所以下次遍历直接从y+1开始；当下次起点大于n，则返回-1
for start < n {
    for i := 0; i < n; i++ {
		realIndex := (start + i) % n
    }
}


167. 两数之和 II - 输入有序数组 !!

下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列
找出满足相加之和等于目标数 target 的两个数
假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素

存在唯一的答案！！！！
初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。

209. 长度最小的子数组
给定一个含有 n 个正整数的数组和一个正整数 target 。
总和大于等于 target 的长度最小的 子数组,返回其长度
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

滑动窗口
遍历一直加，符合条件左边一直减，直到不符合，继续遍历

30. 串联所有单词的子串
输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]

思路简单，写起来麻烦，虽然自己写对了

hashmap + 滑动窗口
hashmap 记录单词库以及个数， 记录当前窗口的单词是否存在
单词出现超过1次时，将左窗口右移到第一次出现的位置的下一个单词，同时窗口对应的hash做调整
单词不存在时，清空窗口的hashmap
注意单词库的单词可以出现多次！

按单词长度分组， 比如 单词长度为2，总共5个单词，则总长度为10， 而s的长度为23
则分组成：
0,2,4,6,8,10,12,14,16,18,20
1,3,5,7,9,11,13,15,17,18,19,21
总共两组
for i := 0; i < wordLength; i++ {
    for j := i; j <= len(s)-wordLength; j += wordLength {

    }
}


36. 有效的数独 ！！！！！
请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）


注意：

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
空白格用 '.' 表示。
board.length == 9
board[i].length == 9
board[i][j] 是一位数字（1-9）或者 '.'

定义三个hash!!

```go
func isValidSudoku(board [][]byte) bool {

	//9个（3x3）单元格
	m := make([][]map[byte]bool, 3)
	for i := 0; i < 3; i++ {
		m[i] = make([]map[byte]bool, 3)
	}
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			m[i][j] = map[byte]bool{}
		}
	}

	//9行
	x := make([]map[byte]bool, 9)
	for i := 0; i < 9; i++ {
		x[i] = map[byte]bool{}
	}
	//9列
	y := make([]map[byte]bool, 9)
	for i := 0; i < 9; i++ {
		y[i] = map[byte]bool{}
	}

	for i := 0; i < len(board); i++ {
		for j := 0; j < len(board[i]); j++ {
			if board[i][j] == '.' {
				continue
			}
			//当前行是否已存在该字符
			if x[i][board[i][j]] {
				return false
			}
			x[i][board[i][j]] = true
			//当前列是否已存在该字符
			if y[j][board[i][j]] {
				return false
			}
			y[j][board[i][j]] = true
			if m[i/3][j/3][board[i][j]] {
				return false
			}
			m[i/3][j/3][board[i][j]] = true
		}
	}
	return true
}
```

73. 矩阵置零 ！！！！
将其所在行和列的所有元素都设为 0

两个变量记录第一行和第一列是否原来有0，然后利用第一行和第一列来记录（第一行和第一列用来记录0无所谓，因为最终这个位置一定是要置0的）
这两次变量的记录要另外遍历


