
# 排序
1. [稳定]冒泡排序：
   + 时间：最坏-O(n^2)、平均-O(n^2)、最好-O(n)； 空间：O(1)
   + 相邻元素两两比较交换，双重循环；
   + 单次遍历没有交换的，提前结束全部遍历
   + length<=1 的数组不需要处理
2. [不稳定]快速排序：
   + 时间：最坏-O(n^2)、平均-O(nlog2n)、最好-O(nlog2n)； 空间：O(nlog2n)
   + 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
   + （高低下标的值交替被替换，最后得到中间下标，把参照值设置回去）for low < high, 每次 v[low]= v[high], v[high]=v[low], 最后v[low]=temp
   + TopK，递归步骤进行剪枝：
     - mid>k, 处理左边部分
     - mid<k, 处理右边部分
     - 结果无序排序的时候可以用
3. [不稳定]堆排序：
   + 时间：最坏-O(nlog2n)、平均-O(nlog2n)、最好-O(nlog2n)； 空间：O(1)
   + 堆的结构可以分为大顶堆和小顶堆，是一个完全二叉树
   + 底层数组结构
   + 大顶堆：`arr(i)>arr(2*i+1) && arr(i)>arr(2*i+2)`；小顶堆：`arr(i)<arr(2*i+1) && arr(i)<arr(2*i+2)`
   + 根找左右：左：`(i+1)*2 - 1`，右：`(i+1)*2` ;
   + 左找根右：根：`(i+1)/2 - 1`，右：`i+1`
   + 右找根左：根：`i/2 - 1`, 左：`i-1`

   + 初始化堆
   + 从最后一个结点的父结点（arr.length / 2 - 1）开始 逐次调整位置，开始构建最大堆
       - 1 若父结点小于左结点，父结点与左结点互换，继续调整
       - 2 若父结点小于右结点，父结点与右结点互换（注意是经过1），继续调整

   + 1 初始化堆，比如小堆：加入堆最后一个结点后，与根节点对比，比根节点小则交换，并继续，否则结束完成（自底向上）
   + 2 调整堆（拿出堆中第一个元素后，即根最后一个结点交换后），将根节点和左右两个元素比较，与较小的那个交换，并继续，若都比自己大，或者已经是叶子结点，则结束完成（自上往下）
   + 如何实现
        1. 实现一个调整堆的方法，传参为nums []int, parent, len int， 即指定根结点parent，从上到下调整，根结点和子结点（先从左右两结点选择满足条件的即可）交换，直到没有子结点
        2. 初始化堆，从最下的根结点到最上的根结点，即从length/2 到0，每个根结点使用上述调整堆的方法
        3. 对堆进行排序，即把根结点（index=0），和最后一个元素交换，然后对[0,length-1]的堆进行调整, 遍历length-1到0， 交换和重新调整堆。
    

+ 其他： https://kingson4wu.github.io/2022/02/28/20220228-%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/

----


