+ go算法常用语法：algorithm-gooooooo/docs/go_code_block.md
+ leetcode刷题参考书：algorithm-gooooooo/docs/leetcode_book.md
+ labuladong刷题参考书：algorithm-gooooooo/docs/labuladong
+ 各种树相关的说明和八股文：algorithm-gooooooo/docs/tree.md
+ algorithm-gooooooo/docs/计算机算法基础总结.pdf

-----

+ algorithm-gooooooo/docs/labuladong/labuladong.md
    - 数据结构的存储方式只有两种:数组(顺序存储)和链表(链式存储)
    - 「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组
    - 「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树
    - 求解动态规划的核心问题是穷举
    - 首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果 暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优 化穷举过程，避免不必要的计算。
      + 解题基本步骤
        1. 找到“状态”和“选择”
        2. 明确dp数组/函数的定义
        3. 寻找状态之间的关系
      + 动态规划算法做的就是穷举 + 剪枝，它俩天生一对儿。所以可以说只要涉及子序列问题，十有八九都需要 动态规划来解决 ！！！
      + DP table 是自底向上求解，递归解法是自顶向下求解 !
      + 动态规划本身也是可以进行阶段性优化的，比如说我们常听说的「状态压缩」技巧，就能够把很多动态规划解法的空间复杂度进一步降低，由 O(N^2) 降低到 O(N)，
    - 快、慢指针的常用算法!!!!
    - 树
        + 递归，自己写方便（刚开始不易理解，但习惯后写起来方便），利用操作系统的栈； 非递归，自己定义栈处理栈。递归地实现 DFS 时，似乎不需要使用任何栈。但实际上，我们使用的是由系统提供的隐式栈，也称为调用栈（Call Stack）
        + 树的遍历方法有广度优先（层序遍历），以及深度优先两种方法，分成先序遍历，中序遍历，后序遍历三种。深度优先使用栈，广度优先使用队列
    


======

# 基础

## 树

### 二叉树
+ 二叉树遍历(先序、中序、后序)
    - 先序（中左右），中序（左中右），后序（左右中）
    - 递归遍历和非递归遍历
    - 二叉树遍历(先序、中序、后序):<https://www.jianshu.com/p/456af5480cee>

+ 二叉查找树 （ Binary Search Tree）
    - 它就是一棵二叉有序树：保证左子树上所有节点的值都小于根节点的值，而右子树上所有节点的值都大于根节点的值。其优点在于实现简单，并且树在平衡的状态下查找效率能达到 O(logଶ)；缺点是在极端非平衡情况下查找效率会退化到 O()，因此很难保证索引的效率。

+ 平衡二叉树 （ Balanced Binary Tree）
    + 针对上述二叉查找树的缺点，人们很自然就想到是否能用平衡二叉树（ Balanced Binary Tree）来解决这个问题。但是平衡二叉树依然有个比较大的问题：它的树高为 logଶ——对于索引树来说，树的高度越高，意味着查找所要花费的访问次数越多，查询效率越低。
      况且，主存从磁盘读数据一般以页为单位，因此每次访问磁盘都会读取多个扇区的数据.
      （比如 4KB大小的数据），远大于单个二叉树节点的值（字节级别），这也是造成二叉树相对索引树效率低下的原因。正因如此，人们就想到了通过增加每个树节点的度来提高访问效率，而 B+树（B+-tree）便受到了更多的关注。
    + 二叉树的度代表某个结点的孩子或者说直接后继的个数，1度是只有一个孩子或者说单子树，2度是有两个孩子或者说左右子树都有
      二叉树的最大度为2

## 图

+ 图的简介:<https://www.cnblogs.com/songgj/p/9107797.html>

### 图结构构成
1. 顶点（vertex）：图中的数据元素.
2. 边（edge）：图中连接这些顶点的线.
### 图的基本概念
1. 无向图（undirected graph）
2. 有向图（directed graph）
3. 混合图（mixed graph） 边同时有的是有方向性有的是无方向型的图。
4. 顶点的度  连接顶点的边的数量称为该顶点的度
5. 邻接顶点 邻接顶点是指图结构中一条边的两个顶点。
    - 入边邻接顶点：连接该顶点的边中的起始顶点。
    - 出边邻接顶点：连接该顶点的边中的结束顶点.
6. 无向完全图
7. 有向完全图
8. 有向无环图（DAG图） 有向无环图可以利用在区块链技术中。有向无环图（Directed Acyclic Graph，DAG）
9. 无权图和有权图  这里的权可以理解成一个数值，就是说节点与节点之间这个边是否有一个数值与它对应
10. 图的连通性 图的每个节点不一定每个节点都会被边连接起来，所以这就涉及到图的连通性
11. 简单图 ( Simple Graph)
+ 对于节点与节点之间存在两种边，这两种边相对比较特殊
  　　1. 自环边（self-loop）：节点自身的边，自己指向自己。
  　　2. 平行边（parallel-edges）：两个节点之间存在多个边相连接。
+ 这两种边都是有意义的，比如从A城市到B城市可能不仅仅有一条路，比如有三条路，这样平行边就可以用到这种情况。不过这两种边在算法设计上会加大实现的难度。而简单图就是不考虑这两种边。


## 其他

### BloomFilter

====

# 常见技巧总结


1. 空间换时间 （最小值栈，结构体保存最小值）
   - algorithm-gooooooo/exercise/leetcode/hot100/155. 最小栈.go ？？
2. 递归：（1）自顶向下的递归，（2）自底向上的递归
3. 使用数组代替hashmap的思想（利用数组的下标）, 空间换取时间
4. 使用hashmap存， k:value, v: index 
5. 移位，与或等运算 （n & (n-1) 每次消除一个1.直到n＝0，就能算出多少个1）；与特殊的值与，特别是题目上有提示多少位的整数
6. 边界注意：负数；是否为空；第一个，最后一个；长度是1；不等于0有，总和有可能由正到负再到正再到负，只有算到最后一个叶子才知道；删除的是头或者尾
7. 字母的ASCII码是数字且固定
8. 递归改成迭代，使用栈 !!!!!
9. 结果反转；涉及反转的可以考虑使用辅助栈
10. 数学计算；善用数学公式推导
11. 链表遍历：两个指针，快慢指针; 两个指针速度相差1，环形情况一定会相遇（在环形区域）（linked-list-cycle）
    因为快慢指针总会到一个圈里不停循环，极端情况下，快指针在圈内循环多几次，总能追上慢指针
12. 动态规划：保存已经计算过的结果，供后续使用
13. 最大值队列（辅助栈，双端队列）
14. 遇到出现次数的题，考虑原地hash的骚操作，利用转负数保留原来的值同时记录状态。出现双数（两次）的，考虑交替正负赋值
    nowcoder/NC30 缺失的第一个正整数.go
15. 旋转数组
    三次翻转 ！！！！
16. 最长无重复子数组
    - 剑指 Offer 48. 最长不含重复字符的子字符串
    - 滑动窗口（双指针）+ hash表！！！！
17. 链表判断入环点, 数组寻找重复数,都可以用Floyd 判圈算法,快慢指针!!!!!
18. 前缀和技巧：exercise/leetcode/hot100/560. 和为 K 的子数组_test.go
19. 随机算法(一次遍历)
    - 水塘算法(逐步缩小范围,判断随机数是否是0)
    - 洗牌算法(逐步缩小范围,交换)
20. 没思路的时候多画图引发思考（比如二分查找的题）！！！！

<pre>
- 单链表翻转（递归或者循环）
- 树的前中后序遍历
- 动态规划（爬楼梯以及变形问题、斐波那契数列、股票问题）
- 二分查找（以及变形）
- 排序（快排）
</pre>

    
====

====

# 分类题目

## 排序

+ algorithm-gooooooo/sort
+ kingson4wu.github.io/source/_posts/20220228-经典排序算法.md
+ https://kingson4wu.github.io/2022/02/28/20220228-%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/

1. [稳定]冒泡排序：
    + algorithm-gooooooo/exercise/sort/bubble_test.go
    + 时间：最坏-O(n^2)、平均-O(n^2)、最好-O(n)； 空间：O(1)
    + 相邻元素两两比较交换，双重循环；
    + 单次遍历没有交换的，提前结束全部遍历
    + length<=1 的数组不需要处理

2. [不稳定]快速排序：
    + algorithm-gooooooo/exercise/sort/quick_test.go
    + 时间：最坏-O(n^2)、平均-O(nlog2n)、最好-O(nlog2n)； 空间：O(nlog2n)
    + 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。!!!
    + （高低下标的值交替被替换，最后得到中间下标，把参照值设置回去）for low < high, 每次 v[low]= v[high], v[high]=v[low], 最后v[low]=temp
    +  每一步都要加上判断：low < high， 不要忘了！！！
    + TopK，递归步骤进行剪枝：
        - mid>k, 处理左边部分
        - mid<k, 处理右边部分
        - 结果无序排序的时候可以用

3. [不稳定]堆排序：
    + algorithm-gooooooo/exercise/sort/heap_test.go
    + algorithm-gooooooo/exercise/leetcode/2024/top100liked/215. 数组中的第K个最大元素_test.go
    + 时间：最坏-O(nlog2n)、平均-O(nlog2n)、最好-O(nlog2n)； 空间：O(1)
    + 堆的结构可以分为大顶堆和小顶堆，是一个完全二叉树
    + 底层数组结构
    + 大顶堆：`arr(i)>arr(2*i+1) && arr(i)>arr(2*i+2)`；小顶堆：`arr(i)<arr(2*i+1) && arr(i)<arr(2*i+2)`
    + 从根结点 找左右：左：`(i+1)*2 - 1`，右：`(i+1)*2` ;
    + 从左结点 找根右：根：`(i+1)/2 - 1`，右：`i+1`
    + 从右结点 找根左：根：`i/2 - 1`, 左：`i-1`

    + 初始化堆
    + 从最后一个结点的父结点（arr.length / 2 - 1）开始 逐次调整位置，开始构建最大堆
        - 左右子节点，找个最大的跟根节点交换！！！
        - 1 若父结点小于左结点，父结点与左结点互换，继续调整
        - 2 若父结点小于右结点，父结点与右结点互换（注意是经过1），继续调整

    + 1 初始化堆，比如小堆：加入堆最后一个结点后，与根节点对比，比根节点小则交换，并继续，否则结束完成（自底向上）
    + 2 调整堆（拿出堆中第一个元素后，即根最后一个结点交换后），将根节点和左右两个元素比较，与较小的那个交换，并继续，若都比自己大，或者已经是叶子结点，则结束完成（自上往下）
    + 如何实现
        1. 实现一个调整堆的方法，传参为nums []int, parent, len int， 即指定根结点parent，从上到下调整，根结点和子结点（先从左右两结点选择满足条件的即可）交换，直到没有子结点
        2. 初始化堆，从最下的根结点到最上的根结点，即从length/2 到0，每个根结点使用上述调整堆的方法
        3. 对堆进行排序，即把根结点（index=0），和最后一个元素交换，然后对[0,length-1]的堆进行调整, 遍历length-1到0， 交换和重新调整堆。
    

+ TopK
    - 不要求有序，使用快排 !!!
    - 要求有序，使用堆；最大堆（前k个最大），最小堆（前k个最小）!!!

-----

## 递归与尾递归
```C
int fact(int n) {
    if(n < 0)
        return 0;
    else if (n == 0 || n == 1)
        return 1;
    else
    return n * fact(n - 1);
}
```
```C
int facttail(int n, int a){
    if (n < 0)
        return 0;
    else if (n == 0)
        return 1;
    else if (n == 1)
        return a;
    else
    return facttail(n - 1, n * a);
}
```

