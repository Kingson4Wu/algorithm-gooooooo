package dp

import (
	"fmt"
	"testing"
)

/*
*
给定一个由 不同 正整数组成的数组 nums ，和一个目标整数 target 。请从 nums 中找出并返回总和为 target 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。

题目数据保证答案符合 32 位整数范围。

示例 1：

输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
*/
/**
个人想法，用全排列回溯来做，
不过感觉会超时
果然
超出时间限制
*/
/*func combinationSum4(nums []int, target int) int {

	count := 0
	sum := 0
	var dfs func()
	dfs = func() {
		if sum >= target {
			if sum == target {
				count++
			}
			return
		}
		for i := 0; i < len(nums); i++ {
			sum += nums[i]
			dfs()
			sum -= nums[i]
		}
	}
	dfs()
	return count
}*/

// 动态规划
/**
dp[i] 表示：组成和为 i 的所有排列方案数
最终答案就是 dp[target]
*/
func combinationSum4(nums []int, target int) int {
	return 0
}

func TestCombinationSum4(t *testing.T) {
	fmt.Println(combinationSum4([]int{1, 2, 3}, 4))
	fmt.Println(combinationSum4([]int{9}, 3))
}

/**
你问的这个问题非常犀利！关键点在于：
**你说得完全对——如果考虑不同顺序，num 放在前面、中间、后面当然是不同的排列！**

但为什么动态规划里我们说 “把 num 放在最后”？这个要靠**思维方式**来理解：

---

## 🧠 一句话解释：

> 我们并不是实际把 `num` 放在排列的最后；我们只是**用“把 num 加在后面”这件事**，来**推导所有可能的顺序排列**。

---

## 🪄 举个例子你就秒懂了：

```go
nums = [1, 2]
target = 3
```

我们用动态规划这样做：

```go
dp[0] = 1  // 凑出 0 的方式只有一种：不选任何数

dp[1] = dp[0] 用 1    → [1]
dp[2] = dp[1] 用 1    → [1,1]
        + dp[0] 用 2  → [2]

dp[3] = dp[2] 用 1    → [1,1,1], [2,1]
        + dp[1] 用 2  → [1,2]
```

你会发现：

* `[1,2]` 来自 `dp[1]` 加 `2`
* `[2,1]` 来自 `dp[2]` 加 `1`

这两个组合，**虽然我们是用“加在后面”的思路推导出来的**，但它们**本质上顺序是不一样的**，都被统计进来了！

---

## ✅ 为什么“加在后面”能覆盖所有顺序？

因为我们是**外层循环枚举目标值（i），内层枚举 nums 里的每个数**，也就是说：

我们会从所有比 i 小的 `dp[i - num]` 中，把 num “放在后面”生成新的排列，
而 `dp[i - num]` 又是由之前所有的更小组合“放 num 在不同位置”推出来的。

所以这个过程是：

> **递推地构建所有可能的顺序排列。**

每个新加的 num 虽然“形式上”是放在末尾，**但因为我们是穷举所有子问题的结果，所以它代表的是所有可能顺序的拼接方式。**

---

## ✅ 换句话说：

| 你担心的问题          | 实际处理方式                                              |
| --------------- | --------------------------------------------------- |
| num 应该也能放在前面或中间 | 动态规划的构建过程已经自动考虑到了这些顺序，只是每一步构建时假设“放在后面”，但最终结果包含了所有顺序 |
| 是不是少算了顺序        | 没有，因为每种顺序在某一步都能被构造出来                                |

---

## 🔁 类比理解

比如你盖房子，每次只会往上加一块砖（看起来总是“放在上面”），但你从所有“底下组合”构建出来的房子，最后长什么样（谁在前谁在后）其实是全部排列的一个结果。

---

## ✅ 总结

* “把 num 放在最后”只是一个**动态规划的构造模型**
* 最终构造出来的 `dp[i]`，包含了所有**顺序不同的排列**
* 所以，即使你没“显式地把 num 放在中间或前面”，它也已经被考虑进来了！

---


func combinationSum4(nums []int, target int) int {
	dp := make([]int, target+1)
	dp[0] = 1  // 只有空组合可以组成 0

	for i := 1; i <= target; i++ {
		for _, num := range nums {
			if i >= num {
				dp[i] += dp[i - num]
			}
		}
	}
	return dp[target]
}

*/
