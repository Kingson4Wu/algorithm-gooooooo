package _025

import (
	"fmt"
	"testing"
)

func findTargetSumWays(nums []int, target int) int {
	if len(nums) == 1 {

		// 这种写法没考虑 +0 ，-0的情况 ！！！
		/*if nums[0] == target || -nums[0] == target {
			return 1
		}*/
		count := 0
		if nums[0] == target {
			count++
		}
		if -nums[0] == target {
			count++
		}
		return count
	}
	sub1 := findTargetSumWays(nums[1:], target-nums[0])
	sub2 := findTargetSumWays(nums[1:], target+nums[0])
	return sub1 + sub2
}

/**
执行用时分布
247
ms
击败
24.33%
复杂度分析
消耗内存分布
3.96
MB
击败
88.33%
复杂度分析

*/

func TestFindTargetSumWays(t *testing.T) {
	fmt.Println(findTargetSumWays([]int{1, 1}, 0))
	fmt.Println(findTargetSumWays([]int{1, 1, 1}, 1))
	fmt.Println(findTargetSumWays([]int{1, 1, 1, 1, 1}, 3))
	fmt.Println(findTargetSumWays([]int{1}, 1))

	//todo
	fmt.Println(findTargetSumWays([]int{1, 0}, 1))
}

/**
nums =
[1,0]
target =
1

添加到测试用例
输出
1
预期结果
2
*/

/**
好问题！你问的是：

> 遍历到第 3 个和第 7 个元素时，`pre - k` 都等于 1，查到 `map[1] = 2`，那不是重复了吗？

其实这正是算法的设计目的！它**不是重复**，而是**精确地统计出了多个不同的子数组**！

---

## 🧠 关键理解：

即使 `pre - k` 得到的值一样，比如都等于 `1`，但 **当前前缀和 `pre` 是不同的**，所以它们对应的子数组也是不同的！

我们看下面这个例子具体分析：

---

## 🧪 示例：

```go
nums = [1, 1, 1, -1, -1, 1, 1]
k = 2
```

我们来一轮一轮模拟，并列出：

* 当前下标 `i`
* 当前前缀和 `pre`
* 查找的 `pre - k`
* `map[pre-k]`
* 有几个合法子数组可以统计

---

### 初始化：

```go
map := {0:1}  // 前缀和为 0 出现过 1 次
pre := 0
count := 0
```

---

| i | nums\[i] | pre | pre - k | m\[pre-k] | count | 子数组（以 i 结尾）                       |
| - | -------- | --- | ------- | --------- | ----- | --------------------------------- |
| 0 | 1        | 1   | -1      | 0         | 0     | 无                                 |
| 1 | 1        | 2   | 0       | 1         | 1     | `[1,1]`                           |
| 2 | 1        | 3   | 1       | 1         | 2     | `[1,1,1]`, `[1,1]`                |
| 3 | -1       | 2   | 0       | 1         | 3     | `[1,1,1,-1]`                      |
| 4 | -1       | 1   | -1      | 0         | 3     | 无                                 |
| 5 | 1        | 2   | 0       | 1         | 4     | `[1,-1,-1,1,1]`                   |
| 6 | 1        | 3   | 1       | 2         | 6     | `[1,-1,1,1]`, `[1,1]`（从 i=4,5 开始） |

---

### 🚩 总共统计到 6 个合法子数组：

1. `[1, 1]`（i=1）
2. `[1, 1, 1]`（i=2）
3. `[1, 1]`（i=2，从下标 1 到 2）
4. `[1, 1, 1, -1]`（i=3）
5. `[1, -1, -1, 1, 1]`（i=5）
6. `[1, -1, 1, 1]`（i=6）
7. `[1, 1]`（i=6，从下标 5 到 6）

等等……你会发现：

* 每一次查 `map[pre - k]` 得到的次数，其实就是：「有几个不同的起点 j，使得从 j+1 到 i 的这段子数组之和为 k」
* **每次加的都是“新的、不同的子数组”**

---

## ✅ 所以总结：

* `map[pre-k]` 可能是相同的值，比如都是 `1`，这没问题
* **但 pre 是变的，每一轮代表一个新的子数组终点**
* 所以统计的子数组都是**不同的，不会重复**

---

### 💬 比喻一下：

想象你走路，一步一步加距离（就是前缀和），
你每次停下来看后面哪些“过去的脚印”（前缀和）和你现在的距离差是 `k`，
如果这些脚印有两个，那就说明有两段不同的路径正好是长度 `k`，你就该加上 2。


*/
